#![no_std]
use embedded_hal::{delay::DelayNs, i2c};

// Registers
const REGISTER_SHUTDOWN: u8 = 0x00;
const REGISTER_BREATHING_CONTROL: u8 = 0x01;
const REGISTER_LED_MODE: u8 = 0x02;
const REGISTER_CURRENT_SETTING: u8 = 0x03;
const REGISTER_LED1_PWM: u8 = 0x04;
const REGISTER_LED2_PWM: u8 = 0x05;
const REGISTER_LED3_PWM: u8 = 0x06;
const REGISTER_DATA_UPDATE: u8 = 0x07;
const REGISTER_LED1_T0: u8 = 0x0A;
const REGISTER_LED2_T0: u8 = 0x0B;
const REGISTER_LED3_T0: u8 = 0x0C;
const REGISTER_LED1_T1T2: u8 = 0x10;
const REGISTER_LED2_T1T2: u8 = 0x11;
const REGISTER_LED3_T1T2: u8 = 0x12;
const REGISTER_LED1_T3T4: u8 = 0x16;
const REGISTER_LED2_T3T4: u8 = 0x17;
const REGISTER_LED3_T3T4: u8 = 0x18;
const REGISTER_TIME_UPDATE: u8 = 0x1C;
const REGISTER_LED_CONTROL: u8 = 0x1D;
const REGISTER_RESET: u8 = 0x2F;

// shutdown register
const SHUTDOWN_CHANNEL_ENABLE: u8 = 0b00_1_0000_0;
const SHUTDOWN_CHANNEL_DISABLE: u8 = 0b00_0_0000_0;
const SOFTWARE_SHUTDOWN_MODE: u8 = 0b00_0_0000_0;
const SOFTWARE_SHUTDOWN_NORMAL: u8 = 0b00_0_0000_1;

    pub enum CurrentSettings {
    Current42mA,
    Current10mA,
    Current5mA,
    Current30mA,
    Current17p5mA,
}

impl Into<u8> for CurrentSettings {
    fn into(self) -> u8 {
        match self {
            CurrentSettings::Current42mA => 0b000_000_00,
            CurrentSettings::Current10mA => 0b000_001_00,
            CurrentSettings::Current5mA => 0b000_010_00,
            CurrentSettings::Current30mA => 0b000_011_00,
            CurrentSettings::Current17p5mA => 0b000_100_00,
        }
    }
}

/// Errors generated by the SN3193 driver
#[derive(Debug)]
pub enum SN3193Error<I2C>
where
    I2C: i2c::I2c,
{
    /// I2C bus error
    I2CError(I2C::Error),
}

pub struct SN3193Driver<I2C, DELAY>
where
    I2C: i2c::I2c,
    DELAY: DelayNs,
{
    i2c: I2C,
    address: u8,
    delay: DELAY,
}

impl<I2C, DELAY> SN3193Driver<I2C, DELAY>
where
    I2C: i2c::I2c,
    DELAY: DelayNs,
{
    /// Default address for the SN3193. This is the address when the AD pin is connected to GND.
    /// The address can be changed by connecting the AD pin to GND, VDD, SCL, or SDA.
    /// The set of available addresses are:
    /// - 0x68 when AD is connected to GND
    /// - 0x6B when AD is connected to VDD
    /// - 0x69 when AD is connected to SCL
    /// - 0x6A when AD is connected to SDA
    pub fn default_address() -> u8 {
        0x68
    }
    pub fn new(i2c: I2C, delay: DELAY) -> Self {
        Self::new_with_address(i2c, delay, Self::default_address())
    }

    pub fn new_with_address(i2c: I2C, delay: DELAY, address: u8) -> Self {
        Self {
            i2c,
            address,
            delay,
        }
    }

    pub fn init(&mut self) -> Result<&mut Self, SN3193Error<I2C>> {
        // start up sequence
        // reset
        self.i2c.write(self.address, &[REGISTER_RESET])
            .map_err(SN3193Error::I2CError)?;

        self.delay.delay_ms(5);
        self.i2c.write(self.address, &[REGISTER_SHUTDOWN, SHUTDOWN_CHANNEL_ENABLE|SOFTWARE_SHUTDOWN_MODE])
            .map_err(SN3193Error::I2CError)?;

        // set mode 0 (PWM)
        self.delay.delay_ms(1);
        self.i2c.write(self.address, &[REGISTER_LED_MODE, 0x00])
            .map_err(SN3193Error::I2CError)?;

        // set current to 17.5 ma and enable all LEDs
        self.set_current(CurrentSettings::Current17p5mA)?.enable_leds(true, true, true)?;

        Ok(self)
    }

    pub fn set_current(&mut self, current: CurrentSettings) -> Result<&mut Self, SN3193Error<I2C>> {
        // things seem to work better with a small delay here, but it's not in the datasheet
        self.delay.delay_ms(1);

        self.i2c.write(self.address, &[REGISTER_CURRENT_SETTING, current.into()])
            .map_err(SN3193Error::I2CError)?;
        Ok(self)
    }

    pub fn enable_leds(&mut self, led1: bool, led2: bool, led3: bool) -> Result<&mut Self, SN3193Error<I2C>> {
        // things seem to work better with a small delay here, but it's not in the datasheet
        self.delay.delay_ms(1);

        let mut led_enable = 0;
        if led1 {
            led_enable |= 0b001;
        }
        if led2 {
            led_enable |= 0b010;
        }
        if led3 {
            led_enable |= 0b100;
        }
        self.i2c.write(self.address, &[REGISTER_LED_CONTROL, led_enable])
            .map_err(SN3193Error::I2CError)?;
        self.load_register_data()
    }

    /// Set the PWM levels for the RGB LED. 255 is full on, 0 is off.
    pub fn set_pwm_levels(&mut self, led1: u8, led2: u8, led3: u8) -> Result<&mut Self, SN3193Error<I2C>> {
        // things seem to work better with a small delay here, but it's not in the datasheet
        self.delay.delay_ms(1);
        self.i2c.write(self.address, &[REGISTER_LED1_PWM, led1])
            .map_err(SN3193Error::I2CError)?;
        // things seem to work better with a small delay here, but it's not in the datasheet
        self.delay.delay_ms(1);
        self.i2c.write(self.address, &[REGISTER_LED2_PWM, led2])
            .map_err(SN3193Error::I2CError)?;
        // things seem to work better with a small delay here, but it's not in the datasheet
        self.delay.delay_ms(1);
        self.i2c.write(self.address, &[REGISTER_LED3_PWM, led3])
            .map_err(SN3193Error::I2CError)?;
        self.load_register_data()
    }

    fn load_register_data(&mut self) -> Result<&mut Self, SN3193Error<I2C>> {
        // things seem to work better with a small delay here, but it's not in the datasheet
        self.delay.delay_ms(1);
        self.i2c.write(self.address, &[REGISTER_DATA_UPDATE, 0xFF])
            .map_err(SN3193Error::I2CError)?;
        Ok(self)
    }

}

#[cfg(test)]
mod tests {
    extern crate std;
    use super::*;
    use embedded_hal_mock::eh1::{
        delay::NoopDelay,
        i2c::{Mock as I2cMock, Transaction as I2cTransaction},
    };

}
